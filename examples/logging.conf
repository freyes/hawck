#The "loggers" section contains the key names for all the loggers in this
#configuration. These are not the actual channel names, but values used to
#identify where the parameters for each logger are found in this file.
#The section for an individual logger is named "logger_xxx" where the "key"
#for a logger is "xxx". So ... "logger_root", "logger_log02", etc. further
#down the file, indicate how the root logger is set up, logger "log_02" is set
#up, and so on.
#Logger key names can be any identifier, except "root" which is reserved for
#the root logger. (The names "lognn" are generated by the GUI configurator.)

[loggers]
keys=root,log02,log03,log04,log05,log06,log07

#The "handlers" section contains the key names for all the handlers in this
#configuration. Just as for loggers above, the key names are values used to
#identify where the parameters for each handler are found in this file.
#The section for an individual handler is named "handler_xxx" where the "key"
#for a handler is "xxx". So sections "handler_hand01", "handler_hand02", etc.
#further down the file, indicate how the handlers "hand01", "hand02" etc.
#are set up.
#Handler key names can be any identifier. (The names "handnn" are generated
#by the GUI configurator.)

[handlers]
keys=hand01,hand02,hand03,hand04,hand05,hand06,hand07,hand08,hand09

#The "formatters" section contains the key names for all the formatters in
#this configuration. Just as for loggers and handlers above, the key names
#are values used to identify where the parameters for each formatter are found
#in this file.
#The section for an individual formatter is named "formatter_xxx" where the
#"key" for a formatter is "xxx". So sections "formatter_form01",
#"formatter_form02", etc. further down the file indicate how the formatters
#"form01", "form02" etc. are set up.
#Formatter key names can be any identifier. (The names "formnn" are generated
#by the GUI configurator.)

[formatters]
keys=form01,form02,form03,form04,form05,form06,form07,form08,form09

#The section below indicates the information relating to the root logger.
#
#The level value needs to be one of DEBUG, INFO, WARN, ERROR, CRITICAL or NOTSET.
#In the root logger, NOTSET indicates that all messages will be logged.
#Level values are eval()'d in the context of the logging package's namespace.
#
#The propagate value indicates whether or not parents of this loggers will
#be traversed when looking for handlers. It doesn't really make sense in the
#root logger - it's just there because a root logger is almost like any other
#logger.
#
#The channel value indicates the lowest portion of the channel name of the
#logger. For a logger called "a.b.c", this value would be "c".
#
#The parent value indicates the key name of the parent logger, except that
#root is shown as "(root)" rather than "root".
#
#The qualname value is the fully qualified channel name of the logger. For a
#logger called "a.b.c", this value would be "a.b.c".
#
#The handlers value is a comma-separated list of the key names of the handlers
#attached to this logger.
#
[logger_root]
level=NOTSET
handlers=hand01
qualname=(root) # note - this is used in non-root loggers
propagate=1 # note - this is used in non-root loggers
channel=
parent=

#
#The explanation for the values in this section is analogous to the above. The
#logger is named "log02" and coincidentally has a key name of "log02". It has
#a level of DEBUG and handler with key name "hand02". (See section
#"handler_hand02" for handler details.) If the level value were NOTSET, this tells
#the logging package to consult the parent (as long as propagate is 1) for the
#effective level of this logger. If propagate is 0, this level is treated as for
#the root logger - a value of NOTSET means "pass everything", and other values are
#interpreted at face value.
#
[logger_log02]
level=DEBUG
propagate=1
qualname=log02
handlers=hand02
channel=log02
parent=(root)

#
#The explanation for the values in this section is analogous to the above. The
#logger is named "log02.log03" and has a key name of "log03".
#It has a level of INFO and handler with key name "hand03".
#
[logger_log03]
level=INFO
propagate=1
qualname=log02.log03
handlers=hand03
channel=log03
parent=log02

#
#The explanations for the values in this section and subsequent logger sections
#are analogous to the above.
#
[logger_log04]
level=WARN
propagate=0
qualname=log02.log03.log04
handlers=hand04
channel=log04
parent=log03

[logger_log05]
level=ERROR
propagate=1
qualname=log02.log03.log04.log05
handlers=hand05
channel=log05
parent=log04

[logger_log06]
level=CRITICAL
propagate=1
qualname=log02.log03.log04.log05.log06
handlers=hand06
channel=log06
parent=log05

[logger_log07]
level=WARN
propagate=1
qualname=log02.log03.log04.log05.log06.log07
handlers=hand07
channel=log07
parent=log06

#The section below indicates the information relating to handler "hand01".
#The first three keys (class, level and formatter) are common to all handlers.
#Any other values are handler-specific, except that "args", when eval()'ed,
#is the list of arguments to the constructor for the handler class.
#
#The class value indicates the handler's class (as determined by eval() in
#the logging package's namespace).
#
#The level value needs to be one of DEBUG, INFO, WARN, ERROR, CRITICAL or NOTSET.
#NOTSET means "use the parent's level".
#
#The formatter value indicates the key name of the formatter for this handler.
#If blank, a default formatter (logging._defaultFormatter) is used.
#
#The stream value indicates the stream for this StreamHandler. It is computed
#by doing eval() on the string value in the context of the logging package's
#namespace.
#
#The args value is a tuple of arguments which is passed to the constructor for
#this handler's class in addition to the "self" argument.
#
[handler_hand01]
class=StreamHandler
level=NOTSET
formatter=form01
args=(sys.stdout,)
stream=sys.stdout

#The section below indicates the information relating to handler "hand02".
#The first three keys are common to all handlers.
#Any other values are handler-specific, except that "args", when eval()'ed,
#is the list of arguments to the constructor for the handler class.
#
#The filename value is the name of the file to write logging information to.
#The mode value is the mode used to open() the file. The maxsize and backcount
#values control rollover as described in the package's API documentation.
#
[handler_hand02]
class=FileHandler
level=DEBUG
formatter=form02
args=('python.log', 'w')
filename=python.log
mode=w

#The section below indicates the information relating to handler "hand03".
#The first three keys are common to all handlers.
#Any other values are handler-specific, except that "args", when eval()'ed,
#is the list of arguments to the constructor for the handler class.
#
#The host value is the name of the host to send logging information to.
#The port value is the port number to use for the socket connection.
#
[handler_hand03]
class=handlers.SocketHandler
level=INFO
formatter=form03
args=('localhost', handlers.DEFAULT_TCP_LOGGING_PORT)
host=localhost
port=DEFAULT_TCP_LOGGING_PORT

#The section below indicates the information relating to handler "hand04".
#The first three keys are common to all handlers.
#Any other values are handler-specific, except that "args", when eval()'ed,
#is the list of arguments to the constructor for the handler class.
#
#The host value is the name of the host to send logging information to.
#The port value is the port number to use for the socket connection.
#
[handler_hand04]
class=handlers.DatagramHandler
level=WARN
formatter=form04
args=('localhost', handlers.DEFAULT_UDP_LOGGING_PORT)
host=localhost
port=DEFAULT_UDP_LOGGING_PORT

#The section below indicates the information relating to handler "hand05".
#The first three keys are common to all handlers.
#Any other values are handler-specific, except that "args", when eval()'ed,
#is the list of arguments to the constructor for the handler class.
#
#The host value is the name of the host to send logging information to.
#The port value is the port number to use for the socket connection.
#The facility is the syslog facility to use for logging.
#
[handler_hand05]
class=handlers.SysLogHandler
level=ERROR
formatter=form05
args=(('localhost', handlers.SYSLOG_UDP_PORT), handlers.SysLogHandler.LOG_USER)
host=localhost
port=SYSLOG_UDP_PORT
facility=LOG_USER

#The section below indicates the information relating to handler "hand06".
#The first three keys are common to all handlers.
#Any other values are handler-specific, except that "args", when eval()'ed,
#is the list of arguments to the constructor for the handler class.
#
#The appname value is the name of the application which appears in the
#NT event log.
#The dllname value is the pathname of a DLL to use for message definitions.
#The logtype is the type of NT event log to write to - Application, Security
#or System.
#
[handler_hand06]
class=NTEventLogHandler
level=CRITICAL
formatter=form06
args=('Python Application', '', 'Application')
appname=Python Application
dllname=
logtype=Application

#The section below indicates the information relating to handler "hand07".
#The first three keys are common to all handlers.
#Any other values are handler-specific, except that "args", when eval()'ed,
#is the list of arguments to the constructor for the handler class.
#
#The host value is the name of the SMTP server to connect to.
#The port value is the port number to use for the SMTP connection.
#The from value is the "From" value in emails.
#The to value is a comma-separated list of email addresses.
#The subject value is the subject of the email.
#
[handler_hand07]
class=SMTPHandler
level=WARN
formatter=form07
args=('localhost', 'from@abc', ['user1@abc', 'user2@xyz'], 'Logger Subject')
host=localhost
port=25
from=from@abc
to=user1@abc,user2@xyz
subject=Logger Subject

#The section below indicates the information relating to handler "hand08".
#The first three keys are common to all handlers.
#Any other values are handler-specific, except that "args", when eval()'ed,
#is the list of arguments to the constructor for the handler class.
#
#The capacity value is the size of this handler's buffer.
#The flushlevel value is the logging level at which the buffer is flushed.
#The from value is the "From" value in emails.
#The target value is the key name of the handler which messages are flushed
#to (i.e. sent to when flushing).
#
[handler_hand08]
class=MemoryHandler
level=NOTSET
formatter=form08
target=
args=(10, ERROR)
capacity=10
flushlevel=ERROR

#The section below indicates the information relating to handler "hand09".
#The first three keys are common to all handlers.
#Any other values are handler-specific, except that "args", when eval()'ed,
#is the list of arguments to the constructor for the handler class.
#
#The host value is the name of the HTTP server to connect to.
#The port value is the port number to use for the HTTP connection.
#The url value is the url to request from the server.
#The method value is the HTTP request type (GET or POST).
#
[handler_hand09]
class=HTTPHandler
level=NOTSET
formatter=form09
args=('localhost:9022', '/log', 'GET')
host=localhost
port=9022
url=/log
method=GET

#The sections below indicate the information relating to the various
#formatters. The format value is the overall format string, and the
#datefmt value is the strftime-compatible date/time format string. If
#empty, the logging package substitutes ISO8601 format date/times where
#needed. See the package API documentation for more details
#of the format string structure.
#
[formatter_form01]
format=F1 %(asctime)s %(levelname)s %(message)s
datefmt=

[formatter_form02]
format=F2 %(asctime)s %(pathname)s(%(lineno)d): %(levelname)s %(message)s
datefmt=

[formatter_form03]
format=F3 %(asctime)s %(levelname)s %(message)s
datefmt=

[formatter_form04]
format=%(asctime)s %(levelname)s %(message)s
datefmt=

[formatter_form05]
format=F5 %(asctime)s %(levelname)s %(message)s
datefmt=

[formatter_form06]
format=F6 %(asctime)s %(levelname)s %(message)s
datefmt=

[formatter_form07]
format=F7 %(asctime)s %(levelname)s %(message)s
datefmt=

[formatter_form08]
format=F8 %(asctime)s %(levelname)s %(message)s
datefmt=

[formatter_form09]
format=F9 %(asctime)s %(levelname)s %(message)s
datefmt=
